\documentclass[class=book, crop=false, oneside, 12pt]{standalone}
\usepackage{standalone}
\usepackage{../../style}
\usepackage[normalem]{ulem}
\graphicspath{{./assets/images/}}

% arara: pdflatex: { synctex: yes, shell: yes }
% arara: latexmk: { clean: partial }
\begin{document}
\chapter{Analisi semantica}

\section{Introduzione all'analisi semantica}

\subsection{Grammatiche attribuite}
Nei capitoli precedenti abbiamo trattato esaustivamente la fase dell'analisi sintattica, in questo capitolo è finalmente arrivato il momento di passare all'analisi semantica.

Per approcciarsi a questa fase del processo della compilazione è necessario introdurre il concetto di grammatica attribuita (Syntax-Directed Definitions, da ora in poi SDD).

Questo tipo di grammatica è tale e quale ad una grammatica di quelle che siamo abituati ad utilizzare ormai quotidianamente, ma ci sorprende con due elementi aggiuntivi:
\begin{itemize}
    \item \textbf{Attributi} che sono associati ai simboli della grammatica e possono essere numeri, tipi, riferimenti alla tabella dei simboli ecc; 
    \item \textbf{Regole} che sono associate alle produzioni della grammatica e di norma sono funzioni degli attributi dei simboli della produzione.
\end{itemize}
Sia simboli che regole sono utilizzati per compiere l'analisi semantica, ovvero dare un valore a quello che è espresso da una parola di un a certa grammatica.

\subsection{Tipi di attributi}

Gli attributi sono divisi in due categorie:
\begin{itemize}
    \item \textbf{attributi sintetizzati}, sono gli attributi del driver di una produzione, questi sono definiti in funzione degli attributi dei simboli del body della produzione;
    \item \textbf{attributi ereditati}, sono gli attributi dei non-terminali nel body della produzione e sono definiti in funzione degli altri simboli del body della produzione.
\end{itemize}
Il lettore accorto si sarà reso cont senz'altro che non abbiamo definito degli attributi per i caratteri terminali, questo perché gli attributi dei terminali sono sempre noti: sono dati dall'analisi lessicale e di conseguenza non serve alcuna regola per calcolarli.
Questo concett risulta ppiù chiaro se si tiene bene a mente che gli attributi servono per valorizzare i caratteri di una parola: i non-terminali hanno un valore che dipende da che funzione rappresentano e da quali terminali "utilizzano", i terminali invece rappresentano le variabili, ovvero dei valori ben definiti che sono già stati riconosciuti e salvati nel momento dell'analisi lessicale.

Di fatto l'analizzatore lessicale prende il codice, sostituisce i terminali con i loro identificatori e ne memorizza il valore.
L'analizzatore lessicale passa poi all'analizzatore sintattico la tabella dei simboli in cui ogni identificatore ha associato il suo valore lessicale (che in seguito indicheremo con la keyword \texttt{lexval}).

È arrivato, come da prassi, il momento di applicare la nostra filosofia del \emph{learning by doing}, osservando un esempio di utilizzo di una grammatica attribuita.

\subsection{Esempio}
Prendiamo come esempio la nostra grammatica per la valutazione delle espressioni aritmetiche per valutare l'espressione rappresentata dall'albero di derivazione in Fig.\ref{fig:first-ex_sdd}.
\begin{align*}
    insert grammar here
\end{align*}
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{first-ex_sdd.jpg}
    \caption{Albero di derivazione per una somma}
    \label{fig:first-ex_sdd}
\end{figure}
Prendiamo il caso in cui il primo digit abbia assegnato come valore 3, mentre il secondo abbia valore 4.
Questi valori, come spiegato prima, sono memorizzati nella tabella dei simboli.

Naturalmente essendo questa una somma tra 3 e 4 ci aspettiamo di trovare, una volta terminata la fase di valutazione, che il valore riportato in \(V\) sia 7.

Vediamo subito quale forma deve avere l'sdd per la grammatica che stiamo utilizzando:
\begin{align}
    \label{reg:regola-1}
    V &\to E & &\{V.val = E.val\} \\
    \label{reg:regola-2}
    E &\to E_1 + T & &\{E.val = E_1.val + T.val\} \\
    \label{reg:regola-3}
    E &\to T & &\{E.val = T.val\} \\
    \label{reg:regola-4}
    T &\to T_1 * F & &\{T.val = T_1.val * F.val\} \\
    \label{reg:regola-5}
    T &\to F & &\{T.val = F.val\} \\
    \label{reg:regola-6}
    F &\to (E) & &\{F.val = E.val\} \\
    \label{reg:regola-7}
    F &\to digit & &\{F.val = digit.lexval\}
\end{align}
\paragraph*{Signifiato delle regole} quelle che abbiamo elencato sulla destra delle produzioni tra parentesi graffe sono le regole che compongono una grammatica attribuita.

\noindent Tutto ciò che si trova all'interno delle regolo sono gli attributi (nota però che i simboli + e * in questo caso non sono attributi, ma sono proprio le operazioni matematiche).

\noindent Proviamo ora a dare una spiegazione del significato delle varie regole così da aiutare il lettore a capire melgio qual è lo scopo delle grammatiche attribuite.
\begin{itemize}
    \item[Reg.\ref{reg:regola-1}] la prima produzione è una produzione aggiuntiva che abbiamo inserito noi  (un po' come \(S' \to S\)) e ci dice che quando incontriamo produzioni \(V \to E\) il valore di \(V\) è \(E.val\);
    \item[Reg.\ref{reg:regola-2}] per produzioni come \(E \to E_1 + T\) avremo che il valore di \(E\) corrisponde alla somma del sottoalbero \(E_1\) più il valore di \(T\) (nota che \(E_1\) è usato solo per differenziare da \(E\));
    \item[Reg.\ref{reg:regola-3}] se ho una produzione \(E \to T\) il valore di \(E\) è uguale al valore di \(T\);
    \item[Reg.\ref{reg:regola-4}] se ho una produzione \(T\to T_1 * F\) il valore di \(T\) corrisponde al valore del sottoalbero \(T_1\) moltiplicato per il valore di \(F\) (nota che \(T_1\) è usato solo per differenziare da \(T\));
    \item[Reg.\ref{reg:regola-5}] se ho una produzione del tipo \(T\to F\) il valore di \(T\) è uguale a \(F.val\);
    \item[Reg.\ref{reg:regola-6}] se ho una produzione del tipo \(F \to (E)\) il valore che assegno a \(F\) corrisponde a \(E.val\);
    \item[Reg.\ref{reg:regola-7}] se ho una produzione del tipo \(F \to digit\) mi aspetto che il valore di \(F\) sia il valore riposrtato nella tabella dei simboli per tale \(digit\).
\end{itemize}

\paragraph*{Utilizzo dell'SDD} ora che abbiamo la grammatica attribuita possiamo utilizzarla appunto per dare un valore al parse tree della nostra somma.

Per valutare un albero di derivazione si utilizza un parse tree annotato. Questo è un parse tree in cui ogni nodo contiene le annotazioni che riguardano gli attributi del simbolo che si trova in quel nodo.
Si può capire al volo cosa intendiamo guardando il parse tree annotato corrispondente al parse tree precedente (Fig.\ref{fig:first-ex_sdd})) che è raffigurato qui sotto.
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{first-ex_noted-parse-tree.jpg}
    \caption{Parse tree annotiato per la somma in \ref{fig:first-ex_sdd}}
    \label{fig:first-ex_noted-parse-tree}
\end{figure}
Ciò a cui si deve fare attenzione in questo caso è che ad ogni nodo è aggiunta l'annotazione riguardante il valore del nodo stesso.

Ma a cosa serve il parse tree annotato? È presto detto!

\noindent Il parse tree annotato viene letto dal basso verso l'alto seguendo le regole di attribuzione che sono segnate sui vari nodi per ottenere la valutazione dell'albeo stesso. Vediamo ora questo procedimento passo per passo.

\begin{enumerate}
    \item Partendo dal basso applichiamo innanzitutto la regola
    \begin{align*}
        F &\to digit & &\{F.val = digit.lexval\}
    \end{align*}
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\textwidth]{first-ex_sdd-resolution-step-1.jpg}
        \caption{Passo 1 della valutazione tramite SDD}
    \end{figure}
    \item Il secondo passo prevede di applicare la regola
    \begin{align*}
        T &\to F & &\{T.val = F.val\}
    \end{align*}
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\textwidth]{first-ex_sdd-resolution-step-2.jpg}
        \caption{Passo 2 della valutazione tramite SDD}
    \end{figure}
    \item Successivamente applichiamo la regola
    \begin{align*}
        E &\to T & &\{E.val = T.val\}
    \end{align*}
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\textwidth]{first-ex_sdd-resolution-step-3.jpg}
        \caption{Passo 3 della valutazione tramite SDD}
    \end{figure}
    \item Il quarto passo prevede di applicare la regola
    \begin{align*}
        E &\to E_1 + T & &\{E.val = E_1.val + T.val\}
    \end{align*}
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\textwidth]{first-ex_sdd-resolution-step-4.jpg}
        \caption{Passo 4 della valutazione tramite SDD}
    \end{figure}
    \item Infine, andiamo ad applicare la regola
    \begin{align*}
        V &\to E & &\{V.val = E.val\}
    \end{align*}
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\textwidth]{first-ex_sdd-resolution-step-5.jpg}
        \caption{Passo finale della valutazione tramite SDD}
    \end{figure}
\end{enumerate}
Dovrebbe essere chiaro a questo punto come si possa utilizzare una grammatica attribuita per calcolare il valore di una certa parola di una data grammatica:
\begin{enumerate}
    \item si crea il parse tree annotato per tale parola;
    \item si utilizza il parse tree annotato in combinazione con le regole dettate dalla grammatica attribuita per valorizzare un nodo alla volta tutti i nodi del parse tree annotato;
    \item una volta valorizzata la radice del parse tree annotato si è ricavato il valore della parola.
\end{enumerate}
Una nota interessante riguardo all'albero di parsing annotato visto in questo esempio è che gli attributi che compaiono in tutti i nodi sono attributi sintetizzati.

\subsection{Verificare se un parse tree annotato può essere valutato}
Non è sempre detto che un parse tree annotato possa essere valutato, per verificare che ciò sia possibile dobbiamo utilizziare un grafo delle dipendenze e verificare che non vi siano conflitti tra le dipendenze.

\paragraph*{Costruire il grfo delle dipendenze} per definire un grafo delle dipendenze per un determinato parse tree annotato dobbiamo svolgere i seguenti passi:

\begin{itemize}
    \item impostiamo un nodo nel grafo delle dipendenze per ogni attributo associato per qualche nodo del parse tree;
    \item per ogni attributo \(X.x\) usato per definire l'attributo \(Y.y\), creiamo un arco dal nodo di \(X.x\) fino al nodo di \(Y.y\) (rappresentando quindi la dipendenza di \(Y.y\) da \(X.x\)).
\end{itemize}

\paragraph*{Utilizzare il grafo delle dipendenze} una volta creato il grafo delle dipendenze, per verificare che non vi siano conflitti dobbiamo trovare un ordinamento topologico per tale grafo; se un ordinamento topologico non esiste, allora l'albero di parsing annotato non è valutabile.

\noindent Se ivece esiste un ordinamento topologico per questo dependency graph allora l'SDD è valutabile ed abbiamo anche un ordine da seguire per la valutazione.

Ad esempio per il parse tree annotato dell'esercizio precedente otteniamo questo grafo delle dipendenze in cui le dipendenze sono indicate con le frecce azzurre (mentre la linea tratteggiata rappresenta gli archi del parse tree).
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{first-ex_sdd-dependency-graph.jpg}
    \caption{Albero di parsing annotato e relativo grafo delle dipendenze}
    \label{fig:first-ex_sdd-dependency-graph}
\end{figure}
Regola: quando tutti gli attributi sono di tipo sintetizzato allora una visita in postordine può sostituire sempre l'ordinamento topologico, capiremo in seguito le motivazioni dietro questa affermazione.

Visita in postorddine, per chi non avesse ascoltato il Montre a suo tempo:
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{postorder-visit.jpg}
    \caption{Algoritmo della visita in postordine, versione PQ}
    \label{fig:postorder-visit}
\end{figure}
Quando un SDD contiene sia elementi sintetizzati che ereditati allora non c'è la garanzia che un ordinamento topologico esista per tale SDD.
Per esempio, se si ha una regola come 
\begin{align*}
    A &\to B & & &\{A.s = B.i; B.i = A.s+7\} 
\end{align*}
si potrebbe trovare un ciclo all'interno del grafo delle dipendenze con una forma simile:
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{dependence-conflict.jpg}
    \caption{Conflitto di dipendenza}
    \label{fig:dependence-conflict}
\end{figure}
Quindi nel caso generale si calcola sempre l'ordinamento topologico dell'SDD, solo nel caso specifico di SDD costituiti solo da attributi sintetizzati ci basta la visita in postordine.

Esistono due classi di SDD per cui è sempre garantita l'esistenza di un ordinamento topologico:
\begin{itemize}
    \item \textbf{S-attributed SDD} (grammatiche o sdd s-attribuiti): tutti gli attributi dell'sdd sono sintetizzati, in questo caso come già detto ci basta fare una visita in postordine;
    \item \textbf{L-attributed SDD}: ci possono essere anche attributi ereditati che rispettano però il seguente vincolo sulle eredità: si può ereditare solo dal padre o dai fratelli sinistri; scrivendo in linguaggio matematico tale vincolo:
    \begin{itemize}
        \item per ogni produzione \(A \to X_1 ... X_n\) la definizione di ogni \(X_j.i\) utilizza solamente
        \begin{itemize}
            \item attributi ereditati di A oppure
            \item attributi sintetizzati o ereditati dei fratelli sinistri di \(X_j\), ovvero \(X_1 ... X_{j-1}\)
        \end{itemize}
    \end{itemize}
\end{itemize}
Gli SDD S-attribuiti sono ideali per il parsing bottom-up, perché si può creare e valutare il parse tree attribuito in contemporanea al parsing della stringa.

\noindent Viceversa gli SDD L-attribuiti sono invece ideali per il parsing top-down, perché si può creare e valutare il parsing tree attribuito in contemporanea al parsing della stringa.

\subsection{Un altro esempio di utilizzo dell'SDD}
Grammatiche differenti pongono sfide differenti nella definizione degli SDD.
Nel primo esercizio di applicazione dell'SDD abbiamo studiato una grammatica con ricorsione sinistra, osserviamo ora un caso di grammatica LL(1), consideriamo il caso della grammatica per le espressioni aritmetiche.
\begin{align*}
    V &\to E \\
    E &\to TE' \\
    E' &\to +TE \mid \varepsilon \\
    T &\to FT' \\
    T' &\to *FT' \mid \varepsilon \\
    F &\to (E) \mid digit \\
\end{align*}
Volgiamo definire l'SDD che ci permette di valutare tale grammatica.

Vediamo di costruire il parse tree di \(3*5\)
Non riportiamo l'intero albero perché la Quaglia non l'ha disegnato.
Questo è un sottoalbero per l'albero di parsing della formula analizzata:
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{second-ex-parse-tree-part.jpg}
    \caption{Pezzo del parse tree di \(3*5\)}
    \label{fig:second-ex-parse-tree-part}
\end{figure}
Osserviamo come in questo caso abbiamo una digit che si trova nel sottoalbero sinistro della radice, mentre l'operatore * e l'altra digit si trovano nel sottoalbero destro della radice.
Come facciamo a fare in modo che \(T.val\) abbia valore \(15\)?

\noindent \emph{Chiediamo l'intervento degli attributi ereditati}

\noindent Questo è il caso in cui possiamo aiutarci con l'utilizzo di attributi ereditati, presentiamo ora in Fig.\ref{fig:second-ex-dependency-graph-part} come si possono utilizzare gli attributi ereditati; in blu abbiamo ancora una volta gli archi del grafo delle dipendenze e le etichette \(.i\) e \(.s\) rappresentano rispetivamente attributi ereditati e sintetizzati.
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{second-ex-dependency-graph-part.jpg}
    \caption{Pezzo del grafo delle dipendenze di \(3*5\)}
    \label{fig:second-ex-dependency-graph-part}
\end{figure}
Vediamo quikndi come in questo caso sia necessario utilizzare gli attributi ereditati, che però aggiungono un livello di complessità.

Quando studiamo la regola per una produzione dobbiamo usare solo le informazioni che abbiamo a quel livello, in quella produzione, così viene affrontata la costruzione dell'SDD.

Andiamo ora a vedere nello specifico come viene affrontata la questione delle dipendenze quando si generano le regole per questo determinato SDD.
La prima cosa da notare è che quando il valore di \(T'\) viene copiato in \(T\) contiene già il valore della moltiplicazione.
In questo caso la regola che andiamo ad associare alla produzione rappresentata è
\begin{align*}
    T &\to FT' & & &\{T'.i = F.s; \; T.s = T'.s\}
\end{align*}
che viene rappresentata graficamente così:
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{second-ex-dependency-graph-part-1.jpg}
    % \label{fig:second-ex-dependency-graph-part-1}
\end{figure}
Se andiamo invece ad osservare come viene generato il valore di \(T'\) vediamo dal pezzo di parse tree annotato in Fig.\ref{fig:second-ex-dependency-graph-part} che in pirmis ereditiamo un elemento dal fratello di sinistra, poi sappiamo che lo moltiplichiamo per il valore che ci è dato da \(F.s\) per ottenere il valore di \(T'_1\), che poi passeremo a \(T'\).

La regola per questa produzione è quindi
\begin{align*}
    T' &\to *FT_1' & & &\{T_1'.i = T'.i * F.s; \; T'.s = T_1'.s\}
\end{align*}
che si può rappresentare graficamente così:
\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{second-ex-dependency-graph-part-2.jpg}
    % \label{fig:second-ex-dependency-graph-part-1}
\end{figure}
Ora che abbiamo studiato i due punti critici dell'SDD per questa grammatica riportiamo l'SDD nella sua completezza.
\begin{align*}
    &V  \to E & &\{V.s = E.s\} \\
    &E  \to TE' & &\{E.s = E'.s; \; E'.i = T.s\} \\
    &E' \to +TE_1' & &\{E'.s = E_1'.s; \; E_1'.i = E'.i + T.s\} \\
    &E' \to \varepsilon & &\{E'.s = E'.i\} \\
    &T  \to FT' & &\{T.s = T'.s; \; T'.i = F.s\} \\
    &T' \to *FT_1' & &\{T'.s = T_1'.s; \; T_1'.i = T'.i * F.s\} \\
    &T' \to \varepsilon & &\{T'.s = T'.i\} \\
    &F  \to (E) & &\{F.s = E.s\} \\
    &F  \to digit & &\{F.s = digit.lexval\}
\end{align*}
Commento dell'SDD, parole testuali dell'insegnate
"Commentiamolo partendo dal fondo

Le prime due sono banali

La terza ci puoi arrivare

La quarta è uno swap

Le prossime due le abbiamo viste prima

Poi abbiamo quelle"

Poi sì vabbè, sbrocca

\noindent Scusate, questa parte è da capire e riscrivere...

\subsection{Traduzione durante il parsing}

Il nostro obiettivo è considerare la traduzione direttamente durante la fase di parsing per poter ottimizzare le attività della compilazione. Questo ci permette di evitare una prima elaborazione sintattica per ottenere il parse tree e la seconda, semantica, per valutare gli attributi.

Il caso più semplice in cui queste due elaborazioni possono essere eseguite in modo congiunto lo si ha considerando una grammatica adatta al parsing bottom-up a cui possiamo applicare l'algoritmo di shift reduce (i.e. SLR(1), LR(1), LALR(1)) e l'SDD è S-Attribuito (i.e. gli unici attributi presenti sono sintetizzati). Come mai?

L'algoritmo di \(shift/reduce\) si può eseguire con complessità lineare e necessità di due pile: una per mantenere gli stati (stSt) mentre l'altra per la catena dei simboli per poter conservare la derivazione parziale (sySt). L'idea è quella che insieme a queste due pile possiamo mantenerne una terza, che chiameremo \textbf{semSt}, dove conserveremo gli attributi (e.g. nel caso di una grammatica di espressioni aritmetiche degli interi).

\subsubsection{Esempio Algoritmo shift/reduce con semSt}

Per poter fornire un'idea di come utilizzare questa pila vediamo un esempio per cui è possibile eseguire il codice nel momento in cui si hanno a disposizione tutte le informazioni sugli attributi dei simboli del body. 

Consideriamo la seguente grammatica per definire le espressioni aritmetiche:
\begin{align*}
    V &\to E \\
    E &\to E + T \mid T \\
    T &\to T * F \mid F \\
    F &\to (E) \mid digit
\end{align*}

Il nostro obiettivo è quello di svolgere la traduzione durante il parsing ma per poter fare ciò abbiamo anche bisogno delle regole associate ad ogni produzione della grammatica

\begin{align*}
    V &\to E &\{print(E.val)\} \\
    E &\to E_1 + T &\{E.val = E_1.val + T.val\} \\
    E &\to T &\{E.val = T.val\} \\
    T &\to T_1 * F &\{T.val = T_1.val * F.val\} \\
    T &\to F &\{T.val = F.val\} \\
    F &\to (E) &\{F.val = E.val\} \\
    F &\to digit &\{F.val = digit.lexval\}
\end{align*}

Come abbiamo potuto osservare nei capitoli precedenti, l'algoritmo \(shift/reduce\) necessita della tabella di parsing per operare. La cortesia di poter osservare che tipo di operazioni venissero eseguite purtroppo non è stata concessa a quei poveri disgraziati che erano a lezione ma, per poter comprendere appieno l'esercizio, ci sentiamo in dovere di fornire, a chiunque stia leggendo, l'automa caratteristico e la relativa tabella di parsing LALR(1).

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{lalr-automata.jpg}
    \label{fig:lalr-automata}
\end{figure}

\begin{table}[H]
    \centering
    \subimport{assets/tables/}{lalr-parsing-table.tex}
    \caption{Tabella di parsing LALR(1) Espressioni Aritmetiche}
    \label{tab:lalr-parsing-table}
\end{table}

dove

\begin{itemize}
    \item[r1:] \(V \to E\) 
    \item[r2:] \(E \to E + T\)
    \item[r3:] \(E \to T\)
    \item[r4:] \(T \to T * F\)
    \item[r5:] \(T \to F\)
    \item[r6:] \(F \to (E)\)
    \item[r7:] \(F \to digit\)
\end{itemize}

Eseguiamo l'algoritmo shift/reduce dato in input \(w = digit + digit\$\) per la grammatica LALR(1) descritta poco sopra. Visto che vogliamo eseguire la traduzione degli attributi durante il parsing supponiamo che il primo abbia valore lessicale pari a 3 (i.e. \(digit.lexval = 3\)) mentre il secondo pari a 4; per questo motivo per poter mantenere traccia degli attributi faremo uso della pila \textbf{semSt} (semantic stack). 

Come sempre iniziamo partendo dallo stato 0 con la seguente situazione iniziale:

\begin{align*}
    w &= digit + digit\$ \\
    stSt &= 0 \\
    symSt &= \\     
    semSt &= \\
\end{align*}

Il primo simbolo che leggiamo dall'input buffer è \(digit\) quindi, come è possibile osservare sia dall'automa caratteristico che dalla parsing table, dobbiamo eseguire un'operazione di \texttt{shift} 6. Oltre che valorizzare le pile durante un normale esecuzione dell'algoritmo eseguiamo \texttt{push} \(digit.lexval\) per poter inserire 3 sulla cima di \(semSt\) a seguito dell'operazione di shift.

\begin{align*}
    w &= \underline{digit} + digit\$ \\
    stSt &= 0\; 6 \\
    symSt &= digit \\     
    semSt &= 3 &\texttt{push}\;digit.lexval \\
\end{align*}

A questo punto il simbolo letto dall'input buffer è \(+\) e, visto che ci troviamo nello stato 6, abbiamo la possibilità di eseguire \texttt{reduce} \(F \to digit\): a seguito di un'operazione di riduzione dobbiamo anche eseguire il codice associato (i.e. la regola) con la produzione \(F \to digit\) (i.e. \(\{F.val = digit.lexval\}\)). In questo caso ciò si traduce in 

\begin{align*}
    w &= \underline{digit} + digit\$ \\
    stSt &= 0\; 4 \\
    symSt &= F &\texttt{reduce}\; F \to digit \\     
    semSt &= 3 &\texttt{pop}\;digit.lexval;\; \texttt{push}\;F.val = digit.lexval\\
\end{align*}

Nello stato 4 abbiamo nuovamente la possibilità di eseguire \texttt{reduce} \(T \to F\) leggendo dall'input buffer un \(+\): in questo caso la regola associata con la produzione è \(\{T.val = F.val\}\) per cui il procedimento sarà simile a quello precedente

\begin{align*}
    w &= \underline{digit} + digit\$ \\
    stSt &= 0\; 3 \\
    symSt &= T &\texttt{reduce}\; T \to F \\     
    semSt &= 3 &\texttt{pop}\;F.val;\; \texttt{push}\;T.val = F.val\\
\end{align*}

Il processo è analogo per lo stato 3 in cui eseguiremo una \texttt{reduce} \(E \to T\) e applicheremo la regola associata \(\{E.val = T.val\}\)

\begin{align*}
    w &= \underline{digit} + digit\$ \\
    stSt &= 0\; 2 \\
    symSt &= E &\texttt{reduce}\; E \to T \\     
    semSt &= 3 &\texttt{pop}\;T.val;\; \texttt{push}\;E.val = T.val \\
\end{align*}

Giunti finalmente nello stato 2 possiamo eseguire \texttt{shift} 7 che ci porta a consumare il simbolo \(+\) dall'input buffer. Visto che abbiamo eseguito uno shift dovremmo caricare il simbolo \(+\) sulla pila \(semSt\) ma ciò creerebbe un'inconsistenza in quanto, tecnicamente, dovrebbe contenere solamente solo dei numeri interi: per poter superare questa problematica carichiamo lo 0 come dummy in modo da mantenere l'allineamento con la pila dei simboli. 

\begin{align*}
    w &= \underline{digit \;+}\; digit\$ \\
    stSt &= 0\; 2\; 7 \\
    symSt &= E\; + \\     
    semSt &= 3\; 0 &\texttt{push}\;dummy\\
\end{align*}

Dallo stato 7 possiamo eseguire \texttt{shift} 6 leggendo dall'input buffer \(digit\): a questo punto possiamo caricare anche il valore del secondo digit sulla pila semantica. 

\begin{align*}
    w &= \underline{digit + digit}\$ \\
    stSt &= 0\; 2\; 7\; 6 \\
    symSt &= E + digit \\     
    semSt &= 3\; 0\; 4 &\texttt{push}\;digit.lexval\\
\end{align*}

Il processo a questo risulta essere analogo a quello fatto precedentemente per il primo \(digit\) quindi ci riserviamo la possibilità di non spiegare così nel dettaglio i prossimi passaggi 

\begin{align*}
    w &= \underline{digit + digit}\$ \\
    stSt &= 0\; 2\; 7\; 4 \\
    symSt &= E + F &\texttt{reduce}\; F \to digit\\     
    semSt &= 3\; 0\; 4 &\texttt{pop}\;digit.lexval;\; \texttt{push}\;F.val = digit.lexval\\
\end{align*}

\begin{align*}
    w &= \underline{digit + digit}\$ \\
    stSt &= 0\; 2\; 7\; 10 \\
    symSt &= E + T &\texttt{reduce}\; T \to F\\     
    semSt &= 3\; 0\; 4 &\texttt{pop}\;F.val;\; \texttt{push}\;T.val = F.val\\
\end{align*}

Nello stato 10 eseguiamo la \texttt{reduce} \(E \to E + T\) leggendo dall'input buffer \$. tale produzione è associata alla regola \(\{E.val = E_1.val + T.val\}\) che ci permette tra le varie cose di eseguire la somma e di rimuovere il dummy dal \(semSt\).

\begin{align*}
    w &= \underline{digit + digit}\$ \\
    stSt &= 0\; 2 \\
    symSt &= E &\texttt{reduce}\; E \to E + T\\     
    semSt &= 7 &\texttt{pop}\;T.val;\; \texttt{pop}\;dummy;\; \texttt{pop}\;E_1.val;\\ 
    && \texttt{push}\;E = E_1.val + T.val\\
\end{align*}

Dallo stato 2 possiamo eseguire questa volta \texttt{reduce} \(V \to E\) in quanto il simbolo che leggiamo dall'input buffer è \$: come sempre associamo a tale produzione la relativa regola (i.e. \(\{print(E.val)\}\)).

\begin{align*}
    w &= \underline{digit + digit}\$ \\
    stSt &= 0\; 1 \\
    symSt &= V &\texttt{reduce}\; V \to E;\; Acc \\     
    semSt &= 7 &\texttt{pop}\;E.val;\; print(E.val)\\
\end{align*}

Questo tipo di approccio è sempre possibile nel caso in cui l'SDD sia S-Attribuito: essendo che siamo in grado di calcolare il valore degli attributi del padre di un sottoalbero solamente sulla base degli attributi dei suoi figli, il modo più facile di implementare l'algoritmo è eseguire le azioni nel momento in cui viene effettuata la riduzione (i.e. il momento in cui conosciamo tutti i valori dei figli). 

Avendo la possibilità di fare un po' più di pre-processing si riesce comunque in bottom-up ad eseguire tale procedura per SDD che sono L-Attribuiti. 

\subsection{Tradurre Stringhe in Numeri}

Analizziamo ora delle grammatiche che permettono di tradurre stringhe in numeri: l'idea è che data una certa stringa vogliamo ottenere il loro valore decimale. 

Possiamo pensare di scrivere una grammatica che genera il linguaggio delle stringhe di digit e il relativo schema di traduzione. 

La prima grammatica su cui ragioneremo è

\begin{align*}
    S &\to Digits	&\{print(Digits.v)\} \\
    Digits &\to Digits_1 d	&\{Digits.v = Digits_1.v * 10 + d.lexval\} \\
    Digits &\to d	&\{Digits.v = d.lexval\}
\end{align*}

La grammatica che abbiamo di fronte è LALR(1) e l'SDD è S-Attribuito: l'ultima affermazione è verificabile dal fatto che il valore del padre dei sottolaberi possibili è sempre e solamente dipendente da quello dei figli. In questo caso dunque è possibile eseguire le due elaborazioni in modo congiunto e quindi possiamo computare il tutto durante il parsing. 

Aggiungiamo una variazione dell'esercizio: ora vogliamo tradurre stringhe di digit al loro valore interpretato in decimale oppure in ottale.

Una possibile grammatica che genera il linguaggio descritto è questa:

\begin{align*}
    S &\to Num \\
    Num &\to o \textrm{ } Digits \mid Digits \\
    Digits &\to Digits \textrm{ } d \mid d
\end{align*}

Quando ci troviamo nel caso di una stringa con il simbolo \(o\) davanti intendiamo che vogliamo ottenere il valore ottale della sequenza di digit. 

La grammatica anche in questo caso è LALR(1) però abbiamo un problema: non è possibile sintetizzare le informazioni nello stesso modo di prima in quanto queste non sono disponibili nel momento in cui ci servono. Ragionando infatti sulla derivazione \(S \Rightarrow Num \Rightarrow o Digits\) ci si rende conto del fatto che il simbolo \(o\) si trova nel sottoalbero sinistro dell'albero mentre i Digits in quello destro: questo vuol dire che di fatto non siamo in grado di computare il valore fino a quando non raggiungiamo la cima dell'albero e quindi ciò significa che non ci troviamo di fronte a un SDD S-Attribuito (il valore del sottoalbero di destra dipende infatti dal valore dei fratelli e non solamente da quello dei figli).

Per poter raggiungere i nostri obbiettivi a livello di efficienza dobbiamo riprovare modificando la grammatica in modo che ci consenta di svolgere entrambe le operazioni contemporaneamente.

Per poter ottenere un risultato migliore potremmo inserire due nuovi non terminali in modo da poterci aiutare con le regole in un secondo momento: consideriamo infatti di modificare la grammatica nel modo seguente

\begin{align*}
    S &\to Num \\
    Num &\to O \textrm{ } Digits \mid D \textrm{ } Digits \\
    O &\to o \\ 
    D &\to \epsilon \\
    Digits &\to Digits \textrm{ } d \mid d
\end{align*}

Di per sé non sembra essere cambiato molto ma in realtà in questo caso abbiamo la possibilità di inserire delle regole dove possiamo valorizzare delle variabili globali in modo da stabilire la base:

\begin{align*}
    S &\to Num &\{print(Num.v)\}\\
    Num &\to O \textrm{ } Digits &\{Num.v = Digits.v\}\\
    Num &\to D \textrm{ } Digits &\{Num.v = Digits.v\}\\
    O &\to o &\{base = 8\}\\ 
    D &\to \epsilon &\{base = 10\}\\
    Digits &\to Digits_1 \textrm{ } d &\{Digits.v = Digits_1.v * base + d.lexval\}\\
    Digits &\to d &\{Digits.v = d.lexval\}
\end{align*}

Stabilendo separatamente la base mediante le regole abbiamo dunque la possibilità di poter svolgere tutti i calcoli necessari senza rinunciare all'efficienza. 


\end{document}
